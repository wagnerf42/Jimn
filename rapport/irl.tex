\documentclass{article}

\usepackage[utf8]{inputenc}

\title{Rapport d'IRL\\Algorithmes d'approximation pour machines outils}
\author{Pierre Petitbon}
\date{\today}

\begin{document}

\maketitle

\section{Analyse de l'existant}

Le logiciel PyCam permet, à partir d'un fichier STL et des caractéristiques du cutter, de trouver un chemin de la fraiseuse pour usiner l'objet décrit par le fichier STL. Ce chemin est décrit par le fichier GCode de sortie.
PyCam procède en deux grandes étapes.
Le Path Generator s'occupe de déterminer l'ensemble des cases à fraiser, l'espace étant discrétisé par un maillage adapté aux caractéristiques du cutter.
Le Path Processor choisit alors un chemin ("toolpath").

PyCam propose plusieurs algorithmes :

Slice Removal consiste à découper l'objet en tranches verticales d'épaisseur fixée, pour l'usiner tranche par tranche. Chaque tranche est partitionnée en bandes de même épaisseur que le cutter. On fait avancer le cutter le long de ces bandes jusqu'à rencontrer l'objet. Cette méthode est donc de type "PushCutter".

Surface consiste à découper l'objet en bandes verticales, et de faire tomber le cutter à intervalles réguliers jusqu'à atteindre la surface de l'objet. Cet algorithme s'adapte aux variations de pente à la surface de l'objet : si la surface entre deux points n'est pas assez plane, ou si la variation de hauteur entre les points est trop importante, on fait tomber à nouveau le cutter entre ces deux points (récursivement). Cette méthode est de type "DropCutter". Pour le calcul du chemin, on procède tranche par tranche, comme dans Slice Removal.

Slice Removal et Surface sont une approche simpliste du problème, mais peu coûteuse : $O(n^{2})$, $n$ étant le nombre de triangles décrits par le fichier STL. En pratique, le temps de calcul est raisonnable. Ce n'est pas le cas du temps de fraisage, qui peut exploser dès que l'objet comporte plusieurs poches : la MCN passe incessamment d'une poche à l'autre, au lieu de les traiter séparément.

Contour Follow propose une approche radicalement différente par rapport aux algorithmes précédents. L'objet est intersecté par des tranches horizontales d'épaisseur fixée. Dans chaque tranche, on réalise une recherche de polynômes par une méthode de contour : on longe (conceptuellement) les polynômes de la tranche avec le cutter. L'ensemble des cases à fraiser est alors défini comme l'intérieur de ces polynômes. Path Processor ne traite plus une dimension après l'autre, il raisonne véritablement en trois dimensions.

Le calcul de chemin par Contour Follow est plus fin : il tient compte du "pocketing" (présence de poches à l'intérieur de l'objet). Cependant, son coût est prohibitif : $O(n^{3})$. En pratique, pour des objets complexes, le temps de calcul peut s'étaler sur plusieurs jours.

Notre problématique est donc de concilier complexité algorithmique (temps de calcul) et degré d'optimalité du chemin (temps de fraisage). Pour parvenir à ce compromis, on a recourt à des algorithmes d'approximation pour le calcul du chemin.

\section{Un nouvel algorithme}

Slice Removal, Surface et Contour Follow étant peu optimisables, nous avons décidé de repartir de zéro. Pour l'implémentation, nous avons choisi le langage Python, qui permet de coder lisiblement et rapidement des algorithmes complexes avec une perte minime de performance par rapport à des langages plus bas niveau.

Nous allons reprendre l'idée de Contour Follow, c'est-à-dire manipuler des polygones, mais de manière plus efficace. De plus, la discrétisation dans les tranches interviendra plus tard que dans Contour Follow : dans chaque tranche, on travaillera en vectoriel aussi longtemps que possible.

L'algorithme se déroule en plusieurs étapes :

\subsection{Parser}

On commence par parser le fichier STL (binaire ou ASCII) en entrée. On note $n$ le nombre de triangles. Cette opération coûte $O(n)$. A l'issue de cette étape, on récupère un ensemble de triangles.

\subsection{Découpage en tranches}

On découpe ensuite l'objet en l'intersectant par des plans horizontaux espacés régulièrement avec un pas de discrétisation adapté. Soit $m$ le nombre de niveaux. On effectue de l'ordre de $O(m.n)$ opérations. A chaque niveau, on obtient un ensemble de segments.

%On effectue certains traitements sur ces segments. On supprime tout d'abord les segments apparaissant un nombre pair de fois : ils sont superflus.

\subsection{Fusion des segments alignés}

On peut alors optionnellement appliquer certains traitements à ces ensembles de segments. Par exemple, on peut fusionner les segments alignés (cette opération n'est pas triviale : les calculs sur flottant étant à précision limitée, l'alignement est rarement exact). Soit $k$ le nombre moyen de segments par tranche. Le coût est alors $O(m.k)$. On a $k \leq n$. En pratique, $k \ll n$.

\subsection{Recherche de polygones}

On passe ensuite à la recherche de polygones à l'intérieur de chaque tranche.

\subsubsection{Création de la table des voisins}

A chaque niveau, on crée et on remplit une table de hachage indexée par les points d’extrémité des segments. Pour chaque point, cette table fournit la liste de ses voisins (un voisin est un point auquel on est relié par un segment).

\subsubsection{Tri des voisins par angle}

Dans la table de hachage précédente, on effectue le traitement suivant :
Pour chaque point, on trie le tableau de ses voisins par angle (Attention : le sens doit être cohérent avec le tri des segments qui va suivre). Nous avons choisi de trier les voisins dans le sens horaire.

\subsubsection{Tri de l'ensemble des segments}

On trie le tableau de segments selon la relation suivante (les critères sont indiqués par priorité décroissante) :

$s1 < s2$ si et seulement si :

a) $s1$ présente le point d’extrémité le plus en bas à gauche (Attention : cohérence).

b) $s1$ décrit l'angle le plus réduit, les angles étant calculés dans le sens trigonométrique (Attention : cohérence).

\subsubsection{Détection de polygones}

On introduit une table pour marquer les segments rencontrés.

On construit les polygones comme suit :

1) Récupérer le premier segment ("le plus en bas à gauche") non marqué.

2) A partir de ce segment, construire un polygone en utilisant la table des voisins. En pratique, on part de l'extrémité gauche du segment initial, et on récupère un voisin jusqu'à retrouver le point de départ.

3) Marquer les segments rencontrés. Plus précisément, on marque les segments qui n'appartiennent qu'au polygone courant.

\end{document}