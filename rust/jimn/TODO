bentley ottmann:

    overlap : 

        two targets:
            1) we want to create intersection points and split on overlap points
               * one version like the old code
               * one version removes SOME overlapping parts (only on one side)
            2) we want to destroy all overlapping parts
               * one version extends current code by having some post-operations
               * one version where segments are pre-removed 

    --------> in fine we need two or three different versions
     a) no overlap anywhere but two different pre-processing
     b) overlap and postprocess to remove
     c) overlap and just be resistant to it (almost current code)



    - we might create points in the present

    - lots of 'move' in closures in Arc. do they inccur overhead ? are they really needed ?

    - treap memory cleaning (we need weak references)

    - it might be possible to create rounding problems:
        consider two consecutive lines (hashed differently) with two almost vertical
        segments intersecting on line 2
        could the x coordinates of intersections with line 1 be equal ?


*********
    - graph: even degrees: move to a "faster" algorithm
      -> take the same hash functions used for detecting nearby points
      -> start with a coarse function
      -> loop on points
          hash it
             while collision detected, rehash everyone with finer function (twice the precision)

      every time a hash is computed, insert all 4 squares in a heap (priority is (granularity,square)) together with corresponding points

      now, loop on the heap taking out the points, we can do again the greedy algorithm
    
    we might lose something on the approx ratio but it still looks like a constant ratio
*********


general:

    - check if we can replace some is_some with if let
    - check where to use array map (point ?)
    - can we replace hashmap's entries with [] ?
